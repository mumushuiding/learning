# 排序与选择算法

<img src="./../img/数据结构-第三章 排序算法.png">

排序问题的实质: 按照某个线性序对一些对象进行排列,键值小的在前,键值大的在后.

待排序数组段为 a[l]~a[r]

简单排序算法:
  * 基于元素间比较
  * 冒泡排序:
    * 基本思想: 把排序纪录看成竖排 **"气泡"** ,键值小的 **上浮**
    * 分析方法:
      * 从底层开始向上遍历处理元素
      * 所谓处理是元素往下依次比较，最终将较小的元素交换至最上层
  * 插入排序:
    * 基本思想: 检查数组中的每个元素,将其插入到一个已排好序的数组中,使数组依然有序.
    * 分析方法:
      * 把第1个待排序元素看做一个已排好序的数组a[l:l+0];
      * 从第二个开始遍历每个待排序元素 x
      * 将 x 同已排好序的数组从后往前依次比较,直到找到一个小于x的元素,并在其后插入x.
  * 选择排序:
    * 基本思想: 从待排序数组中选择最小的元素放在已排序的数组后面.
    * 分析方法:
      * 先从待排序纪录中选出最小值放在第一位
      * 从剩下的纪录中选出次小值放在第二位
      * 依此类推

快速排序算法:
  * 基于元素间比较
  * 基于分治策略的排序算法,性能取决于划分的对称性.
  * 时间复杂性: O(nlogn)
  * 快速排序:
    * 基本思想: 
      * 分解: 将数组分成三段,使得左半段都小于中间段(就一个元素),右半段都大于中间段
      * 递归求解: 分别对左右半段进行排序
      * 合并: 合并之后的数组已经是排好序了.
  * 随机快速排序法: 性能取决于划分的对称性,随机生成划分基准,从而可以期望划分是较对称的
    * 方法:
      * 生成left和right之间的随机数i
      * 交换i和right指向的元素
      * 后面同快速排序相同
  * 三数取中划分算法: 选择数组头尾中3个数的中位数作为划分基准,从而改进划分的对称性.
    *  比基本快速排序法快20%~25%;
    * 方法：
      * 找到头尾中的中位数存入right-1位置
      * 然后对[left+1,right-1]进行递归划分
  * 三划分快速排序算法： 将数组分成左中右三段，左段小于基准，中段等于基准，右段大于基准，然后对左右两段进行递归排序
    * 当存在大量键值相同的元素时，可以明显改进算法的性能
    方法：
      * 将最右边的元素设置为基准v
      * 将数组划分成左中右三段
      * 对左段和右段数组进行递归排序

合并排序算法：
  * 基于元素之间比较
  * 基于分治策略
  * 基本思想：
    * 将待排序数组分成大小相同的两个子集a,b
    * 分别对a,b进行排序
    * 合并a,b
线性时间排序算法：
  * 计数排序算法：对每个输入元素X，确定输入序列中键值小于x的元素个数，这样就能最终确定x的位置
    * 时间复杂性为 O(n)： 取得线性时间上界的前提是元素值 m=O(n) 作了一定限制。
  * 桶排序算法：设置若干个桶，将键值等于i的元素全部装入第i个桶中;然后，按桶的顺序将桶中元素顺序连接起来。 
    * 时间复杂性为 O(n)：条件是元素值 m=O(n)
  * 基数排序算法：
    * 方法：
      * 将输入数据看成具有相同长度的正整数，较短的用0补齐
      * 从低位到高位，依次对上一轮排序后数据的高一位数值做一次排序
    * 时间复杂性：O(wn)
      * 计数排序算法中涉及的元素存在上界，为基数(RADIX),所以复杂性为 O(n)
      * 计数排序循环次数为最大值的位数 w
      * 时间复杂为O(wn)
中位数与第k小元素：
  * 平均情况下的线性时间选择算法 
    * 基本思想： 
      * 模仿快速排序算法设计出来的
      * 对输入数组进行递归划分 
      * 对划分出来的子数组之一进行递归处理
    * 时间复杂性：
      * 最坏情况下，算法需要O(n2)
      * 平均情况下，需要O(n)
  * 最坏情况下的线性时间选择算法
    * 

